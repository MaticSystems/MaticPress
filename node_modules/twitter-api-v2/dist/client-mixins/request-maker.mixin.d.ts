/// <reference types="node" />
import { IClientSettings, TwitterRateLimit, TwitterResponse } from '../types';
import TweetStream from '../stream/TweetStream';
import OAuth1Helper from './oauth1.helper';
import type { IGetHttpRequestArgs, IGetStreamRequestArgs, IGetStreamRequestArgsAsync, IGetStreamRequestArgsSync, IWriteAuthHeadersArgs } from '../types/request-maker.mixin.types';
export declare abstract class ClientRequestMaker {
    protected _bearerToken?: string;
    protected _consumerToken?: string;
    protected _consumerSecret?: string;
    protected _accessToken?: string;
    protected _accessSecret?: string;
    protected _basicToken?: string;
    protected _clientId?: string;
    protected _clientSecret?: string;
    protected _oauth?: OAuth1Helper;
    protected _rateLimits: {
        [endpoint: string]: TwitterRateLimit;
    };
    protected _clientSettings: Partial<IClientSettings>;
    protected static readonly BODY_METHODS: Set<string>;
    protected saveRateLimit(originalUrl: string, rateLimit: TwitterRateLimit): void;
    /** Send a new request and returns a wrapped `Promise<TwitterResponse<T>`. */
    send<T = any>(requestParams: IGetHttpRequestArgs): Promise<TwitterResponse<T>>;
    /**
     * Create a new request, then creates a stream from it as a `TweetStream`.
     *
     * Request will be sent only if `autoConnect` is not set or `true`: return type will be `Promise<TweetStream>`.
     * If `autoConnect` is `false`, a `TweetStream` is directly returned and you should call `stream.connect()` by yourself.
     */
    sendStream<T = any>(requestParams: IGetHttpRequestArgs & IGetStreamRequestArgsSync): TweetStream<T>;
    sendStream<T = any>(requestParams: IGetHttpRequestArgs & IGetStreamRequestArgsAsync): Promise<TweetStream<T>>;
    sendStream<T = any>(requestParams: IGetHttpRequestArgs & IGetStreamRequestArgs): Promise<TweetStream<T>> | TweetStream<T>;
    protected buildOAuth(): OAuth1Helper;
    protected getOAuthAccessTokens(): {
        key: string;
        secret: string;
    } | undefined;
    protected writeAuthHeaders({ headers, bodyInSignature, url, method, query, body }: IWriteAuthHeadersArgs): Record<string, string>;
    protected getHttpRequestArgs({ url, method, query: rawQuery, body: rawBody, headers, forceBodyMode, enableAuth, params, }: IGetHttpRequestArgs): {
        rawUrl: string;
        url: URL;
        method: string;
        headers: Record<string, string>;
        body: string | Buffer | undefined;
    };
}
